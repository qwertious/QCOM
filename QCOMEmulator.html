<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>JS Emulator</title>
    <style>
      body {
        background: black;
        color: white;
        font-family: monospace;
      }
      canvas {
        border: 1px solid white;
        display: block;
        margin: auto;
      }
    </style>
  </head>
  <body>
    <canvas id="screen" width="640" height="480"></canvas>
    <input type="file" id="romInput" accept=".qcom" />
    <script>
      document
        .getElementById("romInput")
        .addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (event) {
            const arrayBuffer = event.target.result;
            const romData = new Uint8Array(arrayBuffer);

            // Resize memory to fit ROM
            memory = new Uint8Array(romData.length);

            // Copy ROM contents into memory
            for (let i = 0; i < romData.length; i++) {
              memory[i] = romData[i];
            }

            // Reset PC to 0x90
            pc = 0x90;
            running = true;

            console.log(
              `Loaded ROM (${romData.length} bytes, memory=${memory.length})`
            );
          };
          reader.readAsArrayBuffer(file);
        });
      // ============================
      // Memory / Registers
      // ============================
      let memory = new Uint8Array();
      let pc = 0x90;
      let displayValue = 0;
      let registers = new Uint8Array(8);

      // ============================
      // Canvas Setup
      // ============================
      const canvas = document.getElementById("screen");
      const ctx = canvas.getContext("2d");
      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;

      const BOARD_SIZE = 16;
      const boardPixels = Math.min(WIDTH, HEIGHT);
      const cellSize = boardPixels / BOARD_SIZE;
      const boardX = (WIDTH - boardPixels) / 2;
      const boardY = (HEIGHT - boardPixels) / 2;

      let showFPS = false;
      let lastTime = performance.now();
      let fps = 0;

      // ============================
      // Flags
      // ============================
      function setZeroFlag(value) {
        if (value === 0) {
          registers[7] |= 0b00000001;
        } else {
          registers[7] &= 0b11111110;
        }
      }

      function getZeroFlag() {
        return registers[7] & 0b00000001;
      }

      function effectiveAddress(addr) {
        const page = (registers[7] >> 4) & 0x0f;
        return ((page << 8) | (addr & 0xff)) % memory.length;
      }

      // ============================
      // Byte â†’ Pixels
      // ============================
      function byteToPixels(byteVal) {
        const r1 = (byteVal >> 7) & 1;
        const g1 = (byteVal >> 6) & 1;
        const b1 = (byteVal >> 5) & 1;
        const color1 = `rgb(${r1 * 255},${g1 * 255},${b1 * 255})`;

        const r2 = (byteVal >> 3) & 1;
        const g2 = (byteVal >> 2) & 1;
        const b2 = (byteVal >> 1) & 1;
        const color2 = `rgb(${r2 * 255},${g2 * 255},${b2 * 255})`;

        return [color1, color2];
      }

      function fetchByte() {
        if (pc < memory.length) {
          return memory[pc++];
        }
        return 0;
      }

      // ============================
      // Instruction Handler (partial)
      // ============================
      function handleInstruction(opcode) {
        switch (opcode) {
          // === DIS ===
          case 0x01: {
            // DIS IMM
            const imm = fetchByte();
            displayValue = imm & 0xff;
            console.log(`DIS IMM ${displayValue}`);
            break;
          }
          case 0x02: {
            // DIS REG
            const reg = fetchByte() & 0x07;
            displayValue = registers[reg] & 0xff;
            console.log(`DIS R${reg} = ${displayValue}`);
            break;
          }
          case 0x03: {
            // DIS ADDR
            const addr = effectiveAddress(fetchByte());
            displayValue = memory[addr] & 0xff;
            console.log(`DIS MEM[${addr}] = ${displayValue}`);
            break;
          }

          // === IN ===
          case 0x04: {
            // IN REG
            const reg = fetchByte() & 0x07;
            registers[reg] = memory[0x80] & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `IN R${reg} <- MEM[0x80] (${registers[reg]
                .toString(2)
                .padStart(8, "0")})`
            );
            break;
          }

          // === OUT ===
          case 0x05: {
            // OUT IMM, IMM
            const port = fetchByte();
            const val = fetchByte() & 0xff;
            console.log(`OUT port ${port}, value ${val}`);
            break;
          }
          case 0x06: {
            // OUT IMM, REG
            const port = fetchByte();
            const reg = fetchByte() & 0x07;
            console.log(`OUT port ${port}, R${reg}=${registers[reg] & 0xff}`);
            break;
          }
          case 0x07: {
            // OUT IMM, ADDR
            const port = fetchByte();
            const addr = effectiveAddress(fetchByte());
            console.log(
              `OUT port ${port}, MEM[${addr}]=${memory[addr] & 0xff}`
            );
            break;
          }

          // === BRK ===
          case 0x0f: {
            console.log("BRK - Break / Halt");
            running = false;
            break;
          }

          // === MOV ===
          case 0x10: {
            // MOV REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const old = registers[reg];
            registers[reg] = imm;
            setZeroFlag(registers[reg]);
            console.log(
              `MOV R${reg}, ${imm} | old=${old} -> new=${registers[reg]}`
            );
            break;
          }
          case 0x11: {
            // MOV ADDR, REG
            const addr = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const old = memory[addr];
            memory[addr] = registers[reg] & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `MOV MEM[${addr}], R${reg} | old=${old} -> new=${memory[addr]}`
            );
            break;
          }
          case 0x12: {
            // MOV REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr = effectiveAddress(fetchByte());
            const old = registers[reg];
            registers[reg] = memory[addr] & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `MOV R${reg}, MEM[${addr}] | old=${old} -> new=${registers[reg]}`
            );
            break;
          }
          case 0x13: {
            // MOV REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const old = registers[reg1];
            registers[reg1] = registers[reg2] & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `MOV R${reg1}, R${reg2} | old=${old} -> new=${registers[reg1]}`
            );
            break;
          }

          // === TODO: continue adding cases for SHW, CLS, shifts, rotates, logic ops, arithmetic, jumps, MIL, etc. ===
          // === SHW ===
          case 0x14: {
            // SHW: Show frame
            console.log("SHW - Show frame");

            // Just trigger the screen redraw
            drawScreen();

            // Optionally: could copy VRAM to a shadow buffer here
            break;
          }

          // === CLS ===
          case 0x15: {
            const color = fetchByte() & 0xff;
            console.log(`CLS - Clear screen to color ${color}`);
            // TODO: clear canvas with this color if rendering
            break;
          }

          // === SHIFTS & ROTATES ===
          case 0x18: {
            // SBL REG
            const reg = fetchByte() & 0x07;
            registers[reg] = (registers[reg] << 1) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `SBL R${reg} -> ${registers[reg].toString(16).padStart(2, "0")}`
            );
            break;
          }
          case 0x19: {
            // SBL ADDR
            const addr = effectiveAddress(fetchByte());
            memory[addr] = (memory[addr] << 1) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `SBL MEM[${addr}] -> ${memory[addr]
                .toString(16)
                .padStart(2, "0")}`
            );
            break;
          }
          case 0x1a: {
            // SBR REG
            const reg = fetchByte() & 0x07;
            registers[reg] = (registers[reg] >> 1) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `SBR R${reg} -> ${registers[reg].toString(16).padStart(2, "0")}`
            );
            break;
          }
          case 0x1b: {
            // SBR ADDR
            const addr = effectiveAddress(fetchByte());
            memory[addr] = (memory[addr] >> 1) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `SBR MEM[${addr}] -> ${memory[addr]
                .toString(16)
                .padStart(2, "0")}`
            );
            break;
          }
          case 0x1c: {
            // RBL REG
            const reg = fetchByte() & 0x07;
            const val = registers[reg];
            registers[reg] = ((val << 1) & 0xff) | ((val >> 7) & 0x01);
            setZeroFlag(registers[reg]);
            console.log(
              `RBL R${reg} -> ${registers[reg].toString(16).padStart(2, "0")}`
            );
            break;
          }
          case 0x1d: {
            // RBL ADDR
            const addr = effectiveAddress(fetchByte());
            const val = memory[addr];
            memory[addr] = ((val << 1) & 0xff) | ((val >> 7) & 0x01);
            setZeroFlag(memory[addr]);
            console.log(
              `RBL MEM[${addr}] -> ${memory[addr]
                .toString(16)
                .padStart(2, "0")}`
            );
            break;
          }
          case 0x1e: {
            // RBR REG
            const reg = fetchByte() & 0x07;
            const val = registers[reg];
            registers[reg] = ((val >> 1) & 0xff) | ((val & 0x01) << 7);
            setZeroFlag(registers[reg]);
            console.log(
              `RBR R${reg} -> ${registers[reg].toString(16).padStart(2, "0")}`
            );
            break;
          }
          case 0x1f: {
            // RBR ADDR
            const addr = effectiveAddress(fetchByte());
            const val = memory[addr];
            memory[addr] = ((val >> 1) & 0xff) | ((val & 0x01) << 7);
            setZeroFlag(memory[addr]);
            console.log(
              `RBR MEM[${addr}] -> ${memory[addr]
                .toString(16)
                .padStart(2, "0")}`
            );
            break;
          }

          // === LOGIC OPERATIONS ===
          case 0x20: {
            // AND REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const old = registers[reg];
            registers[reg] = registers[reg] & imm & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `AND R${reg}, ${imm} | ${old} & ${imm} = ${registers[reg]}`
            );
            break;
          }
          case 0x21: {
            // AND ADDR, REG
            const addr = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const old = memory[addr];
            memory[addr] = memory[addr] & registers[reg] & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `AND MEM[${addr}], R${reg} | ${old} & ${registers[reg]} = ${memory[addr]}`
            );
            break;
          }
          case 0x22: {
            // AND REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr = effectiveAddress(fetchByte());
            const old = registers[reg];
            registers[reg] = registers[reg] & memory[addr] & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `AND R${reg}, MEM[${addr}] | ${old} & ${memory[addr]} = ${registers[reg]}`
            );
            break;
          }
          case 0x23: {
            // AND REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const old = registers[reg1];
            registers[reg1] = registers[reg1] & registers[reg2] & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `AND R${reg1}, R${reg2} | ${old} & ${registers[reg2]} = ${registers[reg1]}`
            );
            break;
          }

          case 0x24: {
            // OR REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const old = registers[reg];
            registers[reg] = (registers[reg] | imm) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `OR R${reg}, ${imm} | ${old} | ${imm} = ${registers[reg]}`
            );
            break;
          }
          case 0x25: {
            // OR ADDR, REG
            const addr = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const old = memory[addr];
            memory[addr] = (memory[addr] | registers[reg]) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `OR MEM[${addr}], R${reg} | ${old} | ${registers[reg]} = ${memory[addr]}`
            );
            break;
          }
          case 0x26: {
            // OR REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr = effectiveAddress(fetchByte());
            const old = registers[reg];
            registers[reg] = (registers[reg] | memory[addr]) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `OR R${reg}, MEM[${addr}] | ${old} | ${memory[addr]} = ${registers[reg]}`
            );
            break;
          }
          case 0x27: {
            // OR REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const old = registers[reg1];
            registers[reg1] = (registers[reg1] | registers[reg2]) & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `OR R${reg1}, R${reg2} | ${old} | ${registers[reg2]} = ${registers[reg1]}`
            );
            break;
          }

          case 0x28: {
            // XOR REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const old = registers[reg];
            registers[reg] = (registers[reg] ^ imm) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `XOR R${reg}, ${imm} | ${old} ^ ${imm} = ${registers[reg]}`
            );
            break;
          }
          case 0x29: {
            // XOR ADDR, REG
            const addr = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const old = memory[addr];
            memory[addr] = (memory[addr] ^ registers[reg]) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `XOR MEM[${addr}], R${reg} | ${old} ^ ${registers[reg]} = ${memory[addr]}`
            );
            break;
          }
          case 0x2a: {
            // XOR REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr = effectiveAddress(fetchByte());
            const old = registers[reg];
            registers[reg] = (registers[reg] ^ memory[addr]) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `XOR R${reg}, MEM[${addr}] | ${old} ^ ${memory[addr]} = ${registers[reg]}`
            );
            break;
          }
          case 0x2b: {
            // XOR REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const old = registers[reg1];
            registers[reg1] = (registers[reg1] ^ registers[reg2]) & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `XOR R${reg1}, R${reg2} | ${old} ^ ${registers[reg2]} = ${registers[reg1]}`
            );
            break;
          }

          case 0x2c: {
            // NOT REG
            const reg = fetchByte() & 0x07;
            const old = registers[reg];
            registers[reg] = ~registers[reg] & 0xff;
            setZeroFlag(registers[reg]);
            console.log(`NOT R${reg} | ~${old} = ${registers[reg]}`);
            break;
          }
          case 0x2d: {
            // NOT ADDR
            const addr = effectiveAddress(fetchByte());
            const old = memory[addr];
            memory[addr] = ~memory[addr] & 0xff;
            setZeroFlag(memory[addr]);
            console.log(`NOT MEM[${addr}] | ~${old} = ${memory[addr]}`);
            break;
          }

          // === ARITHMETIC ===
          case 0x30: {
            // ADD REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const old = registers[reg];
            registers[reg] = (registers[reg] + imm) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `ADD R${reg}, ${imm} | ${old} + ${imm} = ${registers[reg]}`
            );
            break;
          }
          case 0x31: {
            // ADD ADDR, REG
            const addr = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const old = memory[addr];
            memory[addr] = (memory[addr] + registers[reg]) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `ADD MEM[${addr}], R${reg} | ${old} + ${registers[reg]} = ${memory[addr]}`
            );
            break;
          }
          case 0x32: {
            // ADD REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr = effectiveAddress(fetchByte());
            const old = registers[reg];
            registers[reg] = (registers[reg] + memory[addr]) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `ADD R${reg}, MEM[${addr}] | ${old} + ${memory[addr]} = ${registers[reg]}`
            );
            break;
          }
          case 0x33: {
            // ADD REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const old = registers[reg1];
            registers[reg1] = (registers[reg1] + registers[reg2]) & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `ADD R${reg1}, R${reg2} | ${old} + ${registers[reg2]} = ${registers[reg1]}`
            );
            break;
          }

          case 0x34: {
            // SUB REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const old = registers[reg];
            registers[reg] = (registers[reg] - imm) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `SUB R${reg}, ${imm} | ${old} - ${imm} = ${registers[reg]}`
            );
            break;
          }
          case 0x35: {
            // SUB ADDR, REG
            const addr = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const old = memory[addr];
            memory[addr] = (memory[addr] - registers[reg]) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(
              `SUB MEM[${addr}], R${reg} | ${old} - ${registers[reg]} = ${memory[addr]}`
            );
            break;
          }
          case 0x36: {
            // SUB REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr = effectiveAddress(fetchByte());
            const old = registers[reg];
            registers[reg] = (registers[reg] - memory[addr]) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `SUB R${reg}, MEM[${addr}] | ${old} - ${memory[addr]} = ${registers[reg]}`
            );
            break;
          }
          case 0x37: {
            // SUB REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const old = registers[reg1];
            registers[reg1] = (registers[reg1] - registers[reg2]) & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `SUB R${reg1}, R${reg2} | ${old} - ${registers[reg2]} = ${registers[reg1]}`
            );
            break;
          }

          case 0x38: {
            // INC REG
            const reg = fetchByte() & 0x07;
            const old = registers[reg];
            registers[reg] = (registers[reg] + 1) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(`INC R${reg} | ${old} + 1 = ${registers[reg]}`);
            break;
          }
          case 0x39: {
            // INC ADDR
            const addr = effectiveAddress(fetchByte());
            const old = memory[addr];
            memory[addr] = (memory[addr] + 1) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(`INC MEM[${addr}] | ${old} + 1 = ${memory[addr]}`);
            break;
          }

          case 0x3a: {
            // DEC REG
            const reg = fetchByte() & 0x07;
            const old = registers[reg];
            registers[reg] = (registers[reg] - 1) & 0xff;
            setZeroFlag(registers[reg]);
            console.log(`DEC R${reg} | ${old} - 1 = ${registers[reg]}`);
            break;
          }
          case 0x3b: {
            // DEC ADDR
            const addr = effectiveAddress(fetchByte());
            const old = memory[addr];
            memory[addr] = (memory[addr] - 1) & 0xff;
            setZeroFlag(memory[addr]);
            console.log(`DEC MEM[${addr}] | ${old} - 1 = ${memory[addr]}`);
            break;
          }

          // === JUMPS ===
          case 0x40: {
            // JMP IMM
            const addr = effectiveAddress(fetchByte());
            console.log(`JMP ${addr}`);
            if (addr >= 0 && addr < memory.length) pc = addr;
            break;
          }
          case 0x41: {
            // JMP REG
            const reg = fetchByte() & 0x07;
            console.log(`JMP R${reg} -> ${registers[reg]}`);
            if (registers[reg] >= 0 && registers[reg] < memory.length)
              pc = effectiveAddress(registers[reg]);
            break;
          }
          case 0x42: {
            // JIF IMM, IMM
            const imm1 = fetchByte();
            const imm2 = effectiveAddress(fetchByte());
            const cond = !!(imm1 & 1);
            const taken = cond && getZeroFlag();
            console.log(
              `JIF ${imm1}, ${imm2} | cond=${cond}, ZF=${getZeroFlag()} -> ${
                taken ? "taken" : "not taken"
              }`
            );
            if (taken && imm2 >= 0 && imm2 < memory.length) pc = imm2;
            break;
          }
          // === JIF ===
          case 0x43: {
            // JIF IMM, REG
            const imm = fetchByte();
            const reg = fetchByte() & 0x07;
            const cond = (imm & 0b00000001) !== 0;
            const taken = cond && getZeroFlag();
            console.log(
              `JIF ${imm}, R${reg} | cond=${cond}, ZF=${getZeroFlag()} -> ${
                taken ? "taken" : "not taken"
              }`
            );
            if (
              taken &&
              registers[reg] >= 0 &&
              registers[reg] < memory.length
            ) {
              pc = effectiveAddress(registers[reg]);
            }
            break;
          }

          // === JNF ===
          case 0x44: {
            // JNF IMM, IMM
            const imm1 = fetchByte();
            const imm2 = effectiveAddress(fetchByte());
            const cond = (imm1 & 0b00000001) !== 0;
            const taken = cond && !getZeroFlag();
            console.log(
              `JNF ${imm1}, ${imm2} | cond=${cond}, ZF=${getZeroFlag()} -> ${
                taken ? "taken" : "not taken"
              }`
            );
            if (taken && imm2 >= 0 && imm2 < memory.length) {
              pc = imm2;
            }
            break;
          }
          case 0x45: {
            // JNF IMM, REG
            const imm = fetchByte();
            const reg = fetchByte() & 0x07;
            const cond = (imm & 0b00000001) !== 0;
            const taken = cond && !getZeroFlag();
            console.log(
              `JNF ${imm}, R${reg} | cond=${cond}, ZF=${getZeroFlag()} -> ${
                taken ? "taken" : "not taken"
              }`
            );
            if (
              taken &&
              registers[reg] >= 0 &&
              registers[reg] < memory.length
            ) {
              pc = effectiveAddress(registers[reg]);
            }
            break;
          }

          // === MIL (Move Indirect Location) ===
          case 0x50: {
            // MIL REG, IMM
            const reg = fetchByte() & 0x07;
            const imm = fetchByte() & 0xff;
            const addr = effectiveAddress(registers[reg]);
            const old = memory[addr];
            memory[addr] = imm;
            setZeroFlag(registers[reg]);
            console.log(
              `MIL R${reg}, ${imm} | old=${old} -> new=${registers[reg]}`
            );
            break;
          }
          case 0x51: {
            // MIL REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const addr = effectiveAddress(registers[reg1]);
            const old = memory[addr];
            memory[addr] = registers[reg2] & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `MIL R${reg1}, R${reg2} | old=${old} -> new=${registers[reg1]}`
            );
            break;
          }
          case 0x52: {
            // MIL REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr2 = fetchByte();
            const addr1 = effectiveAddress(registers[reg]);
            const old = memory[addr1];
            memory[addr1] = memory[addr2] & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `MIL R${reg}, MEM[${addr2}] | old=${old} -> new=${registers[reg]}`
            );
            break;
          }
          case 0x53: {
            // MIL ADDR, REG
            const addr1 = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const addr2 = effectiveAddress(memory[addr1]);
            const old = memory[addr2];
            memory[addr2] = registers[reg] & 0xff;
            setZeroFlag(memory[addr2]);
            console.log(
              `MIL MEM[${addr1}], R${reg} | old=${old} -> new=${memory[addr2]}`
            );
            break;
          }
          // === MFI (Move From Indirect) ===
          case 0x54: {
            //MFI REG, REG
            const reg1 = fetchByte() & 0x07;
            const reg2 = fetchByte() & 0x07;
            const addr = effectiveAddress(registers[reg2]);
            const old = registers[reg2];
            registers[reg1] = memory[addr] & 0xff;
            setZeroFlag(registers[reg1]);
            console.log(
              `MFI R${reg1}, R${reg2} | old=${old} -> new=${registers[reg1]}`
            );
            break;
          }
          case 0x55: {
            // MFI REG, ADDR
            const reg = fetchByte() & 0x07;
            const addr2 = fetchByte();
            const addr1 = effectiveAddress(memory[addr2]);
            const old = memory[addr2];
            registers[reg] = memory[addr1] & 0xff;
            setZeroFlag(registers[reg]);
            console.log(
              `MFI R${reg}, MEM[${addr2}] | old=${old} -> new=${registers[reg]}`
            );
            break;
          }
          case 0x56: {
            // MFI ADDR, REG
            const addr1 = effectiveAddress(fetchByte());
            const reg = fetchByte() & 0x07;
            const addr2 = effectiveAddress(registers[reg]);
            const old = registers[reg];
            memory[addr1] = memory[addr2] & 0xff;
            setZeroFlag(memory[addr1]);
            console.log(
              `MFI MEM[${addr1}], R${reg} | old=${old} -> new=${memory[addr1]}`
            );
            break;
          }
          case 0x57: {
            // MFI ADDR, ADDR
            const addr1 = effectiveAddress(fetchByte());
            const addr2 = effectiveAddress(fetchByte());
            const addr3 = effectiveAddress(memory[addr2]);
            const old = memory[addr2];
            memory[addr1] = memory[addr3] & 0xff;
            setZeroFlag(memory[addr1]);
            console.log(
              `MFI MEM[${addr1}], MEM[${addr2}] | old=${old} -> new=${memory[addr1]}`
            );
            break;
          }

          default:
            console.log(
              `Unknown opcode: 0x${opcode
                .toString(16)
                .padStart(2, "0")
                .toUpperCase()}`
            );
            break;
        }
      }

      // ============================
      // Draw Screen
      // ============================
      function drawScreen() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        if (showFPS) {
          ctx.fillStyle = "white";
          ctx.fillText(`FPS: ${fps.toFixed(2)}`, 10, 20);
        }

        // Binary + hex display
        const binStr = displayValue.toString(2).padStart(8, "0");
        const hexStr =
          "0x" + displayValue.toString(16).padStart(2, "0").toUpperCase();
        ctx.fillText(binStr, WIDTH - 80, 20);
        ctx.fillText(hexStr, WIDTH - 80, 40);

        // Board rendering
        let addr = 0x00;
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x += 2) {
            const byteVal = memory[addr++];
            const [c1, c2] = byteToPixels(byteVal);

            ctx.fillStyle = c1;
            ctx.fillRect(
              boardX + x * cellSize,
              boardY + y * cellSize,
              cellSize,
              cellSize
            );

            ctx.fillStyle = c2;
            ctx.fillRect(
              boardX + (x + 1) * cellSize,
              boardY + y * cellSize,
              cellSize,
              cellSize
            );
          }
        }
      }

      // ============================
      // Controller Input
      // ============================
      const keys = {};
      document.addEventListener("keydown", (e) => (keys[e.code] = true));
      document.addEventListener("keyup", (e) => (keys[e.code] = false));

      function updateController() {
        let controllerByte = 0;
        if (keys["KeyW"]) controllerByte |= 1 << 7;
        if (keys["KeyS"]) controllerByte |= 1 << 6;
        if (keys["KeyA"]) controllerByte |= 1 << 5;
        if (keys["KeyD"]) controllerByte |= 1 << 4;
        if (keys["Space"]) controllerByte |= 1 << 3;
        if (keys["ShiftLeft"] || keys["ShiftRight"]) controllerByte |= 1 << 2;
        if (keys["Enter"]) controllerByte |= 1 << 1;
        if (keys["Backspace"]) controllerByte |= 1 << 0;

        memory[0x80] = controllerByte;
      }

      // ============================
      // Main Loop
      // ============================
      let running = true;
      let targetFPS = 100;
      let lastFrameTime = performance.now();
      const INSTRUCTIONS_PER_FRAME = 10;

      function loop() {
        if (!running) return;

        const now = performance.now();
        const delta = now - lastFrameTime;

        if (delta >= 1000 / targetFPS) {
          lastFrameTime = now;

          updateController();

          for (
            let i = 0;
            i < INSTRUCTIONS_PER_FRAME && running && pc < memory.length;
            i++
          ) {
            const opcode = memory[pc++];
            handleInstruction(opcode);
          }
        }

        requestAnimationFrame(loop);
      }

      // ============================
      // Start
      // ============================
      drawScreen();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
